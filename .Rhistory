for(i in length(args)){
assign(x = names(args)[i], value = args[[i]]))
}
#lapply(args, function(x) assign(x = names(args)[x], value = args[[x]]))
}
ellipsis_fun = function(...){
args = list(...)
for(i in length(args)){
assign(x = names(args)[i], value = args[[i]])
}
#lapply(args, function(x) assign(x = names(args)[x], value = args[[x]]))
}
ellipsis_fun(a = 1, b = 2, c = "d")
ls()
rm(ellipsis_fun())
rm(list = ls())
install.packages("ellipsis")
install.packages("ellipsis")
library(ellipsis)
make_generator_instances = function(assembled, n.dim, n.cluster, path_to_testdata,
path_to_salesperson, ...){
#generator_instances = list()
check_dots_empty()
#tsp.rue.ls = load_rue_instances(assembled)
#tsp.netgen.cluster.ls = load_netgen.cluster_instances(assembled, n.dim, n.cluster)
#tsp.netgen.grid.ls = load_netgen.grid_instances(assembled, n.dim)
#tsp.lib.ls = load_tsplib_instances(path_to_testdata, path_to_salesperson)
'generator_instances = list.append(generator_instances,
tsp.rue = tsp.rue.ls,
tsp.netgen.cluster = tsp.netgen.cluster.ls,
tsp.netgen.grid = tsp.netgen.grid.ls,
tsp.lib= tsp.lib.ls)'
#return(generator_instances)
}
test_gen_ls = make_generator_instances(assembled, n.dim = 2L, n.cluster = 10L, path_to_testdata,
path_to_salesperson)
setwd("/Users/bjornbreilmann/Desktop/Jakob_MA/MA_AutomatedAlgoSelection_for_TSP/MA_bjoern_MASTER_CODE_LOCAL/salesperson-master")
library(pryr)
library(listviewer)
library(devtools)
library(rlist)
library(plyr)
library(dplyr)
library(DataCombine)
library(data.table)
library(dplyr)
library(RColorBrewer)
library(GGally)
load_all(path = ".")
setwd("/Users/bjornbreilmann/Desktop/local-Jacob/Feature_Package")
load_all(path = ".")
eax_bin_PATH_ = "/Users/bjornbreilmann/Desktop/Jakob_MA/MA_AutomatedAlgoSelection_for_TSP/MA_bjoern_MASTER_CODE_LOCAL/TSP_solvers_Bin/EAX/main"
lkh_bin_PATH_ = "/Users/bjornbreilmann/Desktop/Jakob_MA/MA_AutomatedAlgoSelection_for_TSP/MA_bjoern_MASTER_CODE_LOCAL/TSP_solvers_Bin/LKH-2.0.7/LKH"
concorde_bin_PATH_ =  "/Users/bjornbreilmann/Desktop/Jakob_MA/MA_AutomatedAlgoSelection_for_TSP/MA_bjoern_MASTER_CODE_LOCAL/TSP_solvers_Bin/concorde/osx/concorde"
solverPaths(list(
"eax" = eax_bin_PATH_,
"lkh" = lkh_bin_PATH_,
"concorde" = concorde_bin_PATH_
))
rm(eax_bin_PATH_, lkh_bin_PATH_, concorde_bin_PATH_)
path_to_rue.500 = "/Users/bjornbreilmann/Desktop/local-Jacob/instances_Jakob/rue500"
path_to_rue.1000 = "/Users/bjornbreilmann/Desktop/local-Jacob/instances_Jakob/rue1000"
rue_names.500 = list.files(path_to_rue.500, pattern="*.tsp$", full.names=TRUE)
rue_names.1000 = list.files(path_to_rue.1000, pattern="*.tsp$", full.names=TRUE)
path_to_evol500.eaxsoph = "/Users/bjornbreilmann/Desktop/local-Jacob/instances_Jakob/evolved500/eax---lkh---sophisticated"
path_to_evol500.lkhsoph = "/Users/bjornbreilmann/Desktop/local-Jacob/instances_Jakob/evolved500/lkh---eax---sophisticated"
path_to_evol1000.eaxsoph = "/Users/bjornbreilmann/Desktop/local-Jacob/instances_Jakob/evolved1000/eax---lkh---sophisticated"
path_to_evol1000.lkhsoph = "/Users/bjornbreilmann/Desktop/local-Jacob/instances_Jakob/evolved1000/lkh---eax---sophisticated"
evol500_names.eaxsoph = list.files(path_to_evol500.eaxsoph, pattern="*.tsp$", full.names=TRUE)
evol500_names.lkhsoph = list.files(path_to_evol500.lkhsoph, pattern="*.tsp$", full.names=TRUE)
evol1000_names.eaxsoph = list.files(path_to_evol1000.eaxsoph, pattern="*.tsp$", full.names=TRUE)
evol1000_names.lkhsoph = list.files(path_to_evol1000.lkhsoph, pattern="*.tsp$", full.names=TRUE)
path_to_netgen.500 = "/Users/bjornbreilmann/Desktop/local-Jacob/instances_Jakob/netgen500"
path_to_netgen.1000 = "/Users/bjornbreilmann/Desktop/local-Jacob/instances_Jakob/netgen1000"
netgen_names.500 = list.files(path_to_netgen.500, pattern="*.tsp$", full.names=TRUE)
netgen_names.1000 = list.files(path_to_netgen.1000, pattern="*.tsp$", full.names=TRUE)
instance_ls = list()
instance_ls = list.append(instance_ls,
rue.500 = rue_names.500,
rue.1000 = rue_names.1000,
evol500.eaxsoph = evol500_names.eaxsoph,
evol500.lkhsoph = evol500_names.lkhsoph,
evol1000.eaxsoph = evol1000_names.eaxsoph,
evol1000.lkhsoph = evol1000_names.lkhsoph,
netgen.500 = netgen_names.500,
netgen.1000 = netgen_names.1000)
rm(path_to_evol500.eaxsoph, path_to_evol500.lkhsoph, path_to_evol1000.eaxsoph, path_to_evol1000.lkhsoph, path_to_netgen.500,
path_to_netgen.1000, evol500_names.eaxsoph, evol500_names.lkhsoph, evol1000_names.eaxsoph, evol1000_names.lkhsoph,
netgen_names.500, netgen_names.1000, path_to_rue.500, path_to_rue.1000, rue_names.500, rue_names.1000)
export_EDA_data = function(path, eda_data_name, file){
write.csv(file, paste(path, eda_data_name, sep=""), row.names = FALSE)
}
names_ls = names(instance_ls)
for(i in 1:length(instance_ls)){ #
k = 0L
name = names_ls[i]
for(j in 1:150){  #150
print(name)
instance = importFromTSPlibFormat(instance_ls[[i]][j], round.distances = TRUE)
res_eax = runSolver("eax", instance, solver.pars = list(cutoff.time = 5))
# PREPARE RES_EAX DATA ----------------------------------------------------------------------------
# impute plateaus and times in original df and copy
# sets attr(..., 'plateauized') <- T/F
res_eax$trajectory = insertPlateaus(res_eax$trajectory)
res_eax$trajectory = imputeTimes(res_eax$trajectory)
res_eax_copy = res_eax
res_eax_copy$trajectory = imputeLastPlateau(res_eax$trajectory)
adder = switch(i,
0,
300,
600,
900,
1200,
1500,
1800,
2100)
group = j + k + adder
k = k + 1L
res_eax$trajectory$groupby = NA
res_eax$trajectory$generator = NA
res_eax$trajectory$label = NA
res_eax$trajectory$groupby = rep(group, length(res_eax$trajectory$iter))
res_eax$trajectory$generator = rep(name, length(res_eax$trajectory$iter))
res_eax$trajectory$label = rep("effective", length(res_eax$trajectory$iter))
res_eax_copy$trajectory$groupby = NA
res_eax$trajectory$generator = NA
res_eax_copy$trajectory$label  = NA
res_eax_copy$trajectory$groupby = rep((group + 1L), length(res_eax_copy$trajectory$iter))
res_eax_copy$trajectory$generator = rep(name, length(res_eax_copy$trajectory$iter))
res_eax_copy$trajectory$label = rep("real", length(res_eax_copy$trajectory$iter))
# EFFECTIVE
plottable_df = res_eax$trajectory
plottable_df = plottable_df %>% dplyr::count(generator, label, groupby)
print(plottable_df)
# 1) IncLB AREA
black.list = c("VRP")
instance = instance
sum_of_lowest_edge_values = try.getFeatureSet(black.list, instance)
inc_lb_stat = getIncLB_area(res_eax$trajectory, sum_of_lowest_edge_values)
plottable_df$IncLB_area = inc_lb_stat$area_sum
# 2)  SUCCESS RATIO
success_ratio = getSuccessRatio(res_eax$trajectory)
plottable_df$success_ratio = success_ratio$successRatio
plottable_df$notSuccessful = success_ratio$num_NoSuccess
# 3) Plateau Statistics
if(attr(res_eax$trajectory,"plateaunized") == TRUE) {
Plat_stats = getPlateauStats(res_eax$trajectory, success_ratio$successRatio)
plottable_df$plat_amnt = Plat_stats$plat_stats$Num_Plateau_Length
plottable_df$max_plat = Plat_stats$plat_stats$Max_Plateau_Length
plottable_df$min_plat = Plat_stats$plat_stats$Min_Plateau_Length
plottable_df$mean_plat = Plat_stats$plat_stats$Mean_Plateau_Length
} else {
plottable_df$plat_amnt = 0L
plottable_df$max_plat = 0L
plottable_df$min_plat = 0L
plottable_df$mean_plat = 0L
}
# 4) Plateau Start Statistics
if(attr(res_eax$trajectory,"plateaunized") == TRUE) {
Plat_start_stats = getPlateauStartStats(res_eax$trajectory, 4, success_ratio$successRatio)
plottable_df$plat_start_X = Plat_start_stats$plat_start$Plats_area_begin_X
plottable_df$plat_start_Y = Plat_start_stats$plat_start$Plats_area_begin_Y
} else {
plottable_df$plat_start_X = 0L
plottable_df$plat_start_Y = 0L
}
# 5) VG (skipped for now)
# TODO: try to derive a paramter here for having a proper/empircal VG threshold
# 5.1) get all drops (decision based on 75% quantile rule)
VG_stats = getVG_stats(res_eax$trajectory)
vg_threshold = VG_stats$vg_stats$vg_threshold
drops = VG_stats$vertical_gaps_data$vg_df
amnt_drops = length(VG_stats$vertical_gaps_data$vg_df)
mean_drops = mean(VG_stats$vertical_gaps_data$vg_df)
default_traj_stats = getDefaultStats(res_eax$trajectory, eff_real_stat = FALSE)
span_inc_traj =  default_traj_stats$incumbent_stat_ls$Span_incumbent
meanDrop_Span_ratio = mean_drops / span_inc_traj
plottable_df$vg_threshold = vg_threshold
plottable_df$amnt_drops = amnt_drops
plottable_df$mean_drops = mean_drops
plottable_df$span_inc_traj = span_inc_traj
plottable_df$meanDrop_Span_ratio = meanDrop_Span_ratio
# 5.2)
VG_start_stats = getVGStartStats(res_eax$trajectory, VG_stats, 5, TRUE)
plottable_df$impro_ratio_10 = (VG_start_stats$ratio_first_perc_ls[1] %>% unlist(.)) %>% as.double(.)
plottable_df$impro_ratio_20 = (VG_start_stats$ratio_first_perc_ls[2] %>% unlist(.)) %>% as.double(.)
plottable_df$impro_ratio_30 = (VG_start_stats$ratio_first_perc_ls[3] %>% unlist(.)) %>% as.double(.)
plottable_df$impro_ratio_40 = (VG_start_stats$ratio_first_perc_ls[4] %>% unlist(.)) %>% as.double(.)
plottable_df$impro_ratio_50 = (VG_start_stats$ratio_first_perc_ls[5] %>% unlist(.)) %>% as.double(.)
plottable_df$VG_in_10 = (VG_start_stats$amnt_ls[1] %>% unlist(.)) %>% as.double(.)
plottable_df$VG_in_20 = (VG_start_stats$amnt_ls[2] %>% unlist(.)) %>% as.double(.)
plottable_df$VG_in_30 = (VG_start_stats$amnt_ls[3] %>% unlist(.)) %>% as.double(.)
plottable_df$VG_in_40 = (VG_start_stats$amnt_ls[4] %>% unlist(.)) %>% as.double(.)
plottable_df$VG_in_50 = (VG_start_stats$amnt_ls[5] %>% unlist(.)) %>% as.double(.)
plottable_df$VG_ratio_10 = (VG_start_stats$ratio_ls[1] %>% unlist(.)) %>% as.double(.)
plottable_df$VG_ratio_20 = (VG_start_stats$ratio_ls[2] %>% unlist(.)) %>% as.double(.)
plottable_df$VG_ratio_30 = (VG_start_stats$ratio_ls[3] %>% unlist(.)) %>% as.double(.)
plottable_df$VG_ratio_40 = (VG_start_stats$ratio_ls[4] %>% unlist(.)) %>% as.double(.)
plottable_df$VG_ratio_50 = (VG_start_stats$ratio_ls[5] %>% unlist(.)) %>% as.double(.)
# 5.3)
gap_power = getGapPower(VG_stats, res_eax$trajectory)
plottable_df$gap_power = gap_power$stat_ellbow_power
plottable_df$gap_power_norm = gap_power$stat_ellbow_power_norm
# 6 last improvements)
plottable_df$impr_last_1 =  (getLastXimprovement(res_eax$trajectory, 0.1)[3] %>% unlist(.)) %>% as.double(.)
plottable_df$impr_last_2 =  (getLastXimprovement(res_eax$trajectory, 0.2)[3] %>% unlist(.)) %>% as.double(.)
plottable_df$impr_last_3 =  (getLastXimprovement(res_eax$trajectory, 0.3)[3] %>% unlist(.)) %>% as.double(.)
plottable_df$impr_last_4 =  (getLastXimprovement(res_eax$trajectory, 0.4)[3] %>% unlist(.)) %>% as.double(.)
plottable_df$impr_last_5 =  (getLastXimprovement(res_eax$trajectory, 0.5)[3] %>% unlist(.)) %>% as.double(.)
# 7) Slopes
slope_stats = getSlopeStats(res_eax$trajectory)
plottable_df$num_slopes = slope_stats$resls_EXCL_ZERO_impro$Num_slopes
plottable_df$min_slopes = slope_stats$resls_EXCL_ZERO_impro$Min_slopes
plottable_df$max_slopes = slope_stats$resls_EXCL_ZERO_impro$Max_slopes
plottable_df$mean_slopes = slope_stats$resls_EXCL_ZERO_impro$Mean_slopes
plottable_df$median_slopes = slope_stats$resls_EXCL_ZERO_impro$Median_slopes
slope_dir_stat = getSlopeDirectionStats(res_eax$trajectory)
plottable_df$slope_dir_changes = slope_dir_stat$Num_direction_change
plottable_df$Min_slopes_i_n = slope_dir_stat$slope_2_stats$Min_slopes_i_n
plottable_df$Max_slopes_i_n = slope_dir_stat$slope_2_stats$Max_slopes_i_n
plottable_df$Mean_slopes_i_n = slope_dir_stat$slope_2_stats$Mean_slopes_i_n
plottable_df$SD_slopes_i_n = slope_dir_stat$slope_2_stats$SD_slopes_i_n
plottable_df$Span_slopes_i_n = slope_dir_stat$slope_2_stats$Span_slopes_i_n
# 8) violation stats)
violation_stats = getVioPlat(res_eax$trajectory, VG_stats, Plat_start_stats, Plat_stats)
plottable_df$vio_ratio_PLAT = violation_stats$vio_ratio_PLAT
# 9) CHULL
chull_stats = getCHULLratio(res_eax$trajectory)
plottable_df$CHULL_spanning_points = chull_stats$chull_spanning_points
plottable_df$RATIO_points_on_CHULL = chull_stats$ratio_chull_allPoints
# TODO: put the other coefficients here as well
# 10) quadratic model fit
qmcoeff = getQuadraticModelCoeff(res_eax$trajectory, TRUE)
plottable_df$rsquared_adj = qmcoeff$summ_coeff_poly$adj.r.squared
# 11) Knee
knee_stats = getKneeRatio(res_eax$trajectory, VG_stats, Plat_start_stats)
plottable_df$KneeAmnt = knee_stats$knee_counter
plottable_df$KneeRatio = knee_stats$knee_ratio
# ---------------------------------------------------------------------------------------
# REAL
plottable_df_copy = res_eax_copy$trajectory
plottable_df_copy = plottable_df_copy %>% dplyr::count(generator, label, groupby)
print(plottable_df_copy)
# 1)
inc_lb_stat_copy = getIncLB_area(res_eax_copy$trajectory, sum_of_lowest_edge_values)
plottable_df_copy$IncLB_area = inc_lb_stat_copy$area_sum
# 2)
success_ratio_copy = getSuccessRatio(res_eax_copy$trajectory)
plottable_df_copy$success_ratio = success_ratio_copy$successRatio
plottable_df_copy$notSuccessful = success_ratio_copy$num_NoSuccess
# 3)
Plat_stats_copy = getPlateauStats(res_eax_copy$trajectory, success_ratio_copy$successRatio)
plottable_df_copy$plat_amnt = Plat_stats_copy$plat_stats$Num_Plateau_Length
plottable_df_copy$plat_amnt = Plat_stats_copy$plat_stats$Num_Plateau_Length
plottable_df_copy$max_plat = Plat_stats_copy$plat_stats$Max_Plateau_Length
plottable_df_copy$min_plat = Plat_stats_copy$plat_stats$Min_Plateau_Length
plottable_df_copy$mean_plat = Plat_stats_copy$plat_stats$Mean_Plateau_Length
# 4)
Plat_start_stats_copy = getPlateauStartStats(res_eax_copy$trajectory, 4, success_ratio_copy$successRatio)
plottable_df_copy$plat_start_X = Plat_start_stats_copy$plat_start$Plats_area_begin_X
plottable_df_copy$plat_start_Y = Plat_start_stats_copy$plat_start$Plats_area_begin_Y
# 5.1)
plottable_df_copy$vg_threshold = 0L
plottable_df_copy$amnt_drops = 0L
plottable_df_copy$mean_drops = 0L
plottable_df_copy$span_inc_traj = 0L
plottable_df_copy$meanDrop_Span_ratio = 0L
# 5.2)
plottable_df_copy$impro_ratio_10 = 0L
plottable_df_copy$impro_ratio_20 = 0L
plottable_df_copy$impro_ratio_30 = 0L
plottable_df_copy$impro_ratio_40 = 0L
plottable_df_copy$impro_ratio_50 = 0L
plottable_df_copy$VG_in_10 = 0L
plottable_df_copy$VG_in_20 = 0L
plottable_df_copy$VG_in_30 = 0L
plottable_df_copy$VG_in_40 = 0L
plottable_df_copy$VG_in_50 = 0L
plottable_df_copy$VG_ratio_10 = 0L
plottable_df_copy$VG_ratio_20 = 0L
plottable_df_copy$VG_ratio_30 = 0L
plottable_df_copy$VG_ratio_40 = 0L
plottable_df_copy$VG_ratio_50 = 0L
# 5.3)
gap_power_copy = 0L #getGapPower(VG_stats, res_eax_copy$trajectory)
plottable_df_copy$gap_power = 0L #gap_power_copy$stat_ellbow_power
plottable_df_copy$gap_power_norm = 0L #gap_power_copy$stat_ellbow_power_norm
# 6)
plottable_df_copy$impr_last_1 =  (getLastXimprovement(res_eax_copy$trajectory, 0.1)[3] %>% unlist(.)) %>% as.double(.)
plottable_df_copy$impr_last_2 =  (getLastXimprovement(res_eax_copy$trajectory, 0.2)[3] %>% unlist(.)) %>% as.double(.)
plottable_df_copy$impr_last_3 =  (getLastXimprovement(res_eax_copy$trajectory, 0.3)[3] %>% unlist(.)) %>% as.double(.)
plottable_df_copy$impr_last_4 =  (getLastXimprovement(res_eax_copy$trajectory, 0.4)[3] %>% unlist(.)) %>% as.double(.)
plottable_df_copy$impr_last_5 =  (getLastXimprovement(res_eax_copy$trajectory, 0.5)[3] %>% unlist(.)) %>% as.double(.)
# 7)
#slope_stats = getSlopeStats(res_eax$trajectory)
plottable_df_copy$num_slopes = 0L
plottable_df_copy$min_slopes = 0L
plottable_df_copy$max_slopes = 0L
plottable_df_copy$mean_slopes = 0L
plottable_df_copy$median_slopes = 0L
slope_dir_stat_copy = getSlopeDirectionStats(res_eax_copy$trajectory)
plottable_df_copy$slope_dir_changes = slope_dir_stat_copy$Num_direction_change
plottable_df_copy$Min_slopes_i_n = slope_dir_stat_copy$slope_2_stats$Min_slopes_i_n
plottable_df_copy$Max_slopes_i_n = slope_dir_stat_copy$slope_2_stats$Max_slopes_i_n
plottable_df_copy$Mean_slopes_i_n = slope_dir_stat_copy$slope_2_stats$Mean_slopes_i_n
plottable_df_copy$SD_slopes_i_n = slope_dir_stat_copy$slope_2_stats$SD_slopes_i_n
plottable_df_copy$Span_slopes_i_n = slope_dir_stat_copy$slope_2_stats$Span_slopes_i_n
# 8)
plottable_df_copy$vio_ratio_PLAT = 0L #triviaL, da einfach ein Plateau mehr
# 9)
chull_stats_copy = getCHULLratio(res_eax_copy$trajectory)
plottable_df_copy$CHULL_spanning_points = chull_stats_copy$chull_spanning_points
plottable_df_copy$RATIO_points_on_CHULL = chull_stats_copy$ratio_chull_allPoints
# 10)
qmcoeff_copy = getQuadraticModelCoeff(res_eax_copy$trajectory, TRUE)
plottable_df_copy$rsquared_adj = qmcoeff_copy$summ_coeff_poly$adj.r.squared
# 11)
plottable_df_copy$KneeAmnt = 0L
plottable_df_copy$KneeRatio = 0L
# GENERATOR LABEL
plottable_df_all = rbind(plottable_df, plottable_df_copy)
if(i == 1 & j == 1){
all_generator_traj = plottable_df_all
} else {
all_generator_traj = rbind(all_generator_traj, plottable_df_all)
}
}
}
View(all_generator_traj)
path = "/Users/bjornbreilmann/Desktop/local-Jacob/EDA/Data/"
eda_data_name = "aggr_stats_150_6-19-20_corrected.csv"
file = all_generator_traj
export_EDA_data(path, eda_data_name, file)
View(file)
for(i in seq(2, length(all_generator_traj$n), by = 2)){
print(i)
all_generator_traj[i - 1L, "generator"] = all_generator_traj[i, "generator"]
}
View(all_generator_traj)
path = "/Users/bjornbreilmann/Desktop/local-Jacob/EDA/Data/"
eda_data_name = "aggr_stats_150_6-19-20_corrected.csv"
file = all_generator_traj
export_EDA_data(path, eda_data_name, file)
all_generator_traj_aggr = file
ggplot(all_generator_traj_aggr[which(all_generator_traj_aggr$label == "effective"), ],
aes(x = generator,
y = max_plat,
fill = generator)) +
geom_jitter(width = 0.2, height = 0.01, size = 1,
aes(colour = factor(generator)),  alpha = 0.7) +
geom_boxplot(notch = T) +
#scale_fill_viridis(discrete = TRUE, alpha=0.9) +
#guides(fill = FALSE) +
ggtitle("{PLateau Max} for each {effective} generator (150 Inst)") +
xlab("") +
ylab("{max value}") +
theme(axis.text.x = element_text(angle = 45, size=5)) +
theme(legend.title = element_blank()) +
guides(fill = FALSE) #+
ggplot(all_generator_traj_aggr,
aes(x = generator,
y = impro_ratio_10,
fill = generator)) +
geom_jitter(width = 0.2, height = 0.01, size = 1,
aes(colour = factor(generator)),  alpha = 0.7) +
geom_boxplot(notch = T) +
#scale_fill_viridis(discrete = TRUE, alpha=0.9) +
#guides(fill = FALSE) +
ggtitle("") +
xlab("") +
ylab("{}") +
theme(axis.text.x = element_text(angle = 45, size=5)) +
theme(legend.title = element_blank()) +
guides(fill = FALSE) +
facet_grid(. ~ all_generator_traj_aggr$label)
ggplot(all_generator_traj_aggr,
aes(x = generator,
y = impro_ratio_20,
fill = generator)) +
geom_jitter(width = 0.2, height = 0.01, size = 1,
aes(colour = factor(generator)),  alpha = 0.7) +
geom_boxplot(notch = T) +
#scale_fill_viridis(discrete = TRUE, alpha=0.9) +
#guides(fill = FALSE) +
ggtitle("") +
xlab("") +
ylab("{}") +
theme(axis.text.x = element_text(angle = 45, size=5)) +
theme(legend.title = element_blank()) +
guides(fill = FALSE) +
facet_grid(. ~ all_generator_traj_aggr$label)
ggplot(all_generator_traj_aggr,
aes(x = generator,
y = impro_ratio30,
fill = generator)) +
geom_jitter(width = 0.2, height = 0.01, size = 1,
aes(colour = factor(generator)),  alpha = 0.7) +
geom_boxplot(notch = T) +
#scale_fill_viridis(discrete = TRUE, alpha=0.9) +
#guides(fill = FALSE) +
ggtitle("") +
xlab("") +
ylab("{}") +
theme(axis.text.x = element_text(angle = 45, size=5)) +
theme(legend.title = element_blank()) +
guides(fill = FALSE) +
facet_grid(. ~ all_generator_traj_aggr$label)
ggplot(all_generator_traj_aggr,
aes(x = generator,
y = VG_in_10,
fill = generator)) +
geom_jitter(width = 0.2, height = 0.01, size = 1,
aes(colour = factor(generator)),  alpha = 0.7) +
geom_boxplot(notch = T) +
#scale_fill_viridis(discrete = TRUE, alpha=0.9) +
#guides(fill = FALSE) +
ggtitle("") +
xlab("") +
ylab("{}") +
theme(axis.text.x = element_text(angle = 45, size=5)) +
theme(legend.title = element_blank()) +
guides(fill = FALSE) +
facet_grid(. ~ all_generator_traj_aggr$label)
library(mlbench)
library(caret)
install.packages("mlbench")
install.packages("caret")
install.packages("caret")
library(mlbench)
library(caret)
data = all_generator_traj
View(all_generator_traj)
data = all_generator_traj
correlationMatrix = cor(data[,4:57])
print(correlationMatrix)
highlyCorrelated = findCorrelation(correlationMatrix, cutoff=0.5)
print(highlyCorrelated)
control <- trainControl(method="repeatedcv", number=10, repeats=3)
model <- train(generator~., data=data, method="lvq", preProcess="scale", trControl=control)
library(e1071)
install.packages("e1071")
library(e1071)
model <- train(generator~., data=data, method="lvq", preProcess="scale", trControl=control)
importance <- varImp(model, scale=FALSE)
model$modelInfo
varImp(model, scale=FALSE)
model <- train(generator~., data=data[,4:57], method="lvq", preProcess="scale", trControl=control)
data.model = data[,4:57]
View(data.model)
View(data.model)
View(file)
data.model = data[,-2]
View(data.model)
data.model = data[,-2]
data.model = data[,-2]
control <- trainControl(method="repeatedcv", number=10, repeats=3)
model <- train(generator~., data=data.model, method="lvq", preProcess="scale", trControl=control)
importance <- varImp(model, scale=FALSE)
test = data(PimaIndiansDiabetes)
data(PimaIndiansDiabetes)
View(PimaIndiansDiabetes)
View(all_generator_traj)
View(all_generator_traj)
summary(all_generator_traj)
importance <- varImp(model, scale=FALSE)
data = all_generator_traj
data.model = data[, -2]
View(data)
data.X = data[, 2:57]
data.Y = data[, 1]
cor(data.X)
data.model = data[, -1:2]
data.model = data[, -c(1:2)]
View(data.model)
View(all_generator_traj)
data.X2 = data[, -c(1:2)] # exlcuding label
rm(data.model)
cor(data.X2)
library(corrplot)
install.packages("corrplot")
library(corrplot)
corrplot(cor(df), method="number", is.corr=FALSE)
corrplot(cor(data.X2), method="number", is.corr=FALSE)
library(corrplot)
corrplot(cor(data.X2), method="number", is.corr=FALSE)
corrplot(cor(data.X2), method="shade", is.corr=FALSE)
corrplot(cor(data.X2), method="circle", is.corr=FALSE)
corrplot(cor(data.X2), method="color", is.corr=FALSE)
data_generator = all_generator_traj
rm(data)
t.test(data_generator$IncLB_area, data_generator$generator)
t.test(data_generator$IncLB_area, data_generator$success_ratio)
install.packages("FSelector")
library(FSelector)
nformation.gain(generator~., data.X2)
FSelector::information.gain(generator~., data.X2)
View(data.X2)
FSelector::information.gain(generator~., data_generator)
feat_importance = sort(as.list(FSelector::information.gain(generator~., data_generator)))
feat_importance = as.list(FSelector::information.gain(generator~., data_generator))
feat_importance
as.list(FSelector::information.gain(generator~., data_generator))
FSelector::information.gain(generator~., data_generator)
feat_importance = FSelector::information.gain(generator~., data_generator)
View(feat_importance)
install.packages("MASS")
install.packages("MASS")
install.packages("MASS")
install.packages("MASS")
library(MASS)
stepAIC(model, direction = "both", trace = FALSE)
MASS::stepAIC(model, direction = "both", trace = FALSE)
